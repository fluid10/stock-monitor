import { Injectable } from '@angular/core';

import { Watchlist } from './watchlist';

import { DbService } from './db.service'

// import nedb from 'nedb';
import * as Datastore from 'nedb';

@Injectable()
export class WatchlistService {
  db: Datastore;

  constructor(private dbService: DbService) {
    this.db = this.dbService.getDb();
  }

  /* Creates new watchlist
     @param watchlist: name of a watchlist
     @return object we saved into DB
  */
  addWatchList(watchlist: string): Promise<Object> {
    return new Promise<Object>(resolve => {
      if (watchlist.length) {
        watchlist = watchlist.charAt(0).toUpperCase() + watchlist.slice(1); // Capitalize first letter of list

        this.db.insert({watchlist_name: watchlist, stocks: [], modified_at: Date.now()}, (err, newDoc) => {
          resolve(newDoc);
        });
      }
    })
  }

  /* Removes watchlist from db
     @param id: id of a watchlist generated by DB
     @return number of removed documents
  */
  removeWatchlist(id: string): Promise<number> {
    return new Promise<number>(resolve => {
      this.db.remove({ _id: id }, {}, (err, numRemoved) => {
        resolve(numRemoved);
      });
    });
  }

  removeAllWatchlists(): Promise<boolean> {
    return new Promise<boolean>(resolve => {
      this.db.remove({}, { multi: true }, () => {
        resolve(true);
      });
    });
  }

  /* Get watchlist from db
     @param id: id of watchlist generated by DB
     @return watchlist object
  */
  getWatchList(id: string): Promise<Watchlist> {
    return new Promise<Watchlist>(resolve => {
      this.db.find({_id: id}, (err, doc) => {
        resolve(doc[0] as Watchlist); // extract watchlist from the array
      })
    })
  }

  removeCompany(id: string, stockSymbol: string): Promise<boolean> {
    return new Promise<boolean>(resolve => {

      this.getWatchList(id)
      .then((watchlist: any) => {

        let stocks = watchlist.stocks.filter(item => { return item.symbol !== stockSymbol; }); // Remove stock
        watchlist.stocks = stocks;

        this.updateStockData(id, watchlist.stocks)
        .then((response) => {
          resolve(response);
        })

      })

    })

  }

  updateStockData(watchlistId: string, stocks: any): Promise<boolean> {
    return new Promise(resolve => {
      this.db.update({ _id: watchlistId }, { $set: { stocks: stocks } }, {}, () => { // Set stocks array with new stock
        resolve(true);
      });
    });
  }

  /* Gets data for portfolio overview page
     @return data object with calculated data
  */
  public getPortfolioOverviewData(): Promise<any> {
    return new Promise<any>(resolve => {

      let data = {};

      this.db.find({}, (err, doc) => {

        data['total_market_value'] = this.totalMarketValueCalculator(doc);
        data['total_day_change'] = this.totalDayChangeCalculator(doc);
        data['market_value_by_watchlist'] = this.getMarketValueByWatchlist(doc);
        data['day_change_by_watchlist'] = this.getDayChangeByWatchlist(doc);

        resolve(data);
      })


    })
  }

  /* Gets day change value for each watchlist object
     @param watchlists: array of watchlists
     @return watchlist object with name & total day change values
  */
  private getDayChangeByWatchlist(watchlists: any): any {
    let data = [];

    watchlists.forEach((watchlist => {
      if (watchlist.stocks) {

        let marketValue = this.totalDayChangeCalculator([watchlist]); // get total day change value for each watchlist
        data.push({watchlist_name: watchlist.watchlist_name, total_day_change: marketValue});

      }

    }));

    return data;
  }

  /* Gets market value for each watchlist object
     @param watchlists: array of watchlists
     @return watchlist object with name & total market value
  */
  private getMarketValueByWatchlist(watchlists: any): any {
    let data = [];

    watchlists.forEach((watchlist => {
      if (watchlist.stocks) {

        let totalMarketValue = this.totalMarketValueCalculator([watchlist]); // get total market value for each watchlist
        data.push({watchlist_name: watchlist.watchlist_name, total_market_value: totalMarketValue});

      }

    }));

    return data;
  }

  /* Calculates total day change of all watchlists combined
     @param watchlists: array of watchlists
     @return total: number of day change value, rounded to 2 decimal points
  */
  private totalDayChangeCalculator(watchlists: any): string {
    let total = 0;

    watchlists.forEach((watchlist) => {
      if (watchlist.stocks) {
        watchlist.stocks.filter((stock) => {
          let dayChange = parseFloat(stock.day_change);

          if (!isNaN(dayChange)) {
            total += dayChange;
          }

        });
      }

    });

    return total.toFixed(2);

  }

  /* Calculates total market value of all watchlists combined
     @param watchlists: array of watchlists
     @return total: number of total market value
  */
  private totalMarketValueCalculator(watchlists: any): number {
    let total = 0;

    let valueSizes = ['M', 'B', 'T'];
    let totalMarketValueSize = '';

    let numberSizes = {"M": 1000000, "B": 1000000000, "T": 1000000000000};
    let numberToMultiplyWith = 0;

    watchlists.forEach((watchlist) => {
      if (watchlist.stocks) {
        watchlist.stocks.filter((stock) => {

          let numberSize = stock.market_value[stock.market_value.length - 1];
          numberSize = numberSizes[numberSize];

          if (numberSize) {
            if (numberToMultiplyWith < numberSize) {
              numberToMultiplyWith = numberSize;
            }
          }

          total += parseFloat(stock.market_value)
        });
      }

    });

    if (numberToMultiplyWith > 0) {
      return total * numberToMultiplyWith;
    } else {
      return total;
    }

  }

  // Gets total market value of all watchlists
  getTotalMarketValue(): Promise<number> {
    return new Promise<number>(resolve => {
      this.db.find({}, (err, doc) => {

        let total = 0;
        doc.forEach((watchlist) => {

          if (watchlist.stocks) {
            watchlist.stocks.filter((stock) => total += parseFloat(stock.market_value));
          }

        });
        resolve(total);
      });
    });
  }

  getTotalDayChange(): Promise<number> {
    return new Promise<number>(resolve => {
      resolve(1.00);
    });
  }

  // Get all watchlists
  getWatchLists(): Promise<Watchlist[]> {
    return new Promise<Watchlist[]>(resolve => {
      let result = [new Watchlist];
      this.db.find({}).sort({watchlist_name: 1}).exec((err, docs) => {
        resolve(docs as Watchlist[]);
      });
    })
  }

}
